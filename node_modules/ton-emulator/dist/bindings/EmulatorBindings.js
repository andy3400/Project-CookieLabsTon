"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _EmulatorBindings_lock, _EmulatorBindings_instances, _EmulatorBindings_module, _EmulatorBindings_errLogs;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmulatorBindings = void 0;
const teslabot_1 = require("teslabot");
const ton_core_1 = require("ton-core");
// WASM bindings
const createModule = require(__dirname + '/../../wasm/emulator-emscripten');
const wasmBinaryPack = require(__dirname + '/../../wasm/emulator-emscripten.wasm.js');
const wasmBinary = Buffer.from(wasmBinaryPack.wasmBinary, 'base64');
const writeToCString = (mod, data) => {
    const len = mod.lengthBytesUTF8(data) + 1;
    const ptr = mod._malloc(len);
    mod.stringToUTF8(data, ptr, len);
    return ptr;
};
const readFromCString = (mod, pointer) => mod.UTF8ToString(pointer);
class EmulatorBindings {
    constructor() {
        _EmulatorBindings_lock.set(this, new teslabot_1.AsyncLock());
        _EmulatorBindings_instances.set(this, new Map());
        _EmulatorBindings_module.set(this, null);
        _EmulatorBindings_errLogs.set(this, []);
        this.invoke = (module, name, args) => {
            // Pointer tracking
            const allocatedPointers = [];
            const trackPointer = (pointer) => {
                allocatedPointers.push(pointer);
                return pointer;
            };
            // Execute 
            try {
                let mappedArgs = args.map((arg) => {
                    if (typeof arg === 'string') {
                        return trackPointer(writeToCString(module, arg));
                    }
                    else {
                        return arg;
                    }
                });
                return module[name](...mappedArgs);
            }
            finally {
                allocatedPointers.forEach((pointer) => module._free(pointer));
            }
        };
    }
    async runGetMethod(args) {
        return await __classPrivateFieldGet(this, _EmulatorBindings_lock, "f").inLock(async () => {
            try {
                // Get module
                let module = await this.getModule();
                // Serialize args
                let stack = (0, ton_core_1.serializeTuple)(args.args);
                // Prepare params
                const params /*: GetMethodInternalParams */ = {
                    code: args.code.toBoc().toString('base64'),
                    data: args.data.toBoc().toString('base64'),
                    verbosity: args.verbosity,
                    libs: '',
                    address: args.address.toRawString(),
                    unixtime: args.unixtime,
                    balance: args.balance.toString(),
                    rand_seed: args.randomSeed.toString('hex'),
                    gas_limit: args.gasLimit.toString(),
                    method_id: args.methodId,
                };
                // Execute
                let res = await this.invoke(module, '_run_get_method', [
                    JSON.stringify(params),
                    stack.toBoc().toString('base64'),
                    args.config.toBoc().toString('base64')
                ]);
                let resStr;
                try {
                    resStr = readFromCString(module, res);
                }
                finally {
                    module._free(res);
                }
                let txres = JSON.parse(resStr);
                let logs = prepareLogs(__classPrivateFieldGet(this, _EmulatorBindings_errLogs, "f"), txres.logs, txres.output.success ? txres.output.vm_log : '');
                if (txres.output.success) {
                    return {
                        logs,
                        output: {
                            success: true,
                            stack: txres.output.stack,
                            gas_used: txres.output.gas_used,
                            vm_exit_code: txres.output.vm_exit_code,
                            missing_library: txres.output.missing_library,
                        }
                    };
                }
                else {
                    return {
                        logs,
                        output: {
                            success: false,
                            error: txres.output.error,
                        }
                    };
                }
            }
            finally {
                __classPrivateFieldSet(this, _EmulatorBindings_errLogs, [], "f");
            }
        });
    }
    async transaction(args) {
        return await __classPrivateFieldGet(this, _EmulatorBindings_lock, "f").inLock(async () => {
            try {
                // Get module
                let module = await this.getModule();
                let instance = this.getInstance(module, args.config, args.verbosity);
                // Params
                const params = {
                    utime: args.now,
                    lt: args.lt.toString(),
                    rand_seed: args.randomSeed.toString('hex'),
                    ignore_chksig: false,
                };
                // Execute
                let res = this.invoke(module, '_emulate', [
                    instance,
                    args.libs ? args.libs.toBoc().toString('base64') : 0,
                    args.shardAccount.toBoc().toString('base64'),
                    args.message.toBoc().toString('base64'),
                    JSON.stringify(params)
                ]);
                let resStr;
                try {
                    resStr = readFromCString(module, res);
                }
                finally {
                    module._free(res);
                }
                // Preprocess result
                let txres = JSON.parse(resStr);
                let logs = prepareLogs(__classPrivateFieldGet(this, _EmulatorBindings_errLogs, "f"), txres.logs, txres.output.vm_log);
                // Convert output
                if (txres.output.success) {
                    return {
                        logs,
                        output: {
                            success: true,
                            transaction: txres.output.transaction,
                            shard_account: txres.output.shard_account,
                            actions: txres.output.actions,
                        }
                    };
                }
                else {
                    return {
                        logs,
                        output: {
                            success: false,
                            error: txres.output.error
                        }
                    };
                }
            }
            finally {
                __classPrivateFieldSet(this, _EmulatorBindings_errLogs, [], "f");
            }
        });
    }
    async getModule() {
        if (!__classPrivateFieldGet(this, _EmulatorBindings_module, "f")) {
            __classPrivateFieldSet(this, _EmulatorBindings_module, await createModule({
                wasmBinary,
                printErr: (text) => __classPrivateFieldGet(this, _EmulatorBindings_errLogs, "f").push(text),
            }), "f");
        }
        let module = __classPrivateFieldGet(this, _EmulatorBindings_module, "f");
        return module;
    }
    getInstance(module, config, verbosity) {
        // Check if instance already exists
        let key = config.hash().toString('hex') + ':' + verbosity;
        if (__classPrivateFieldGet(this, _EmulatorBindings_instances, "f").has(key)) {
            return __classPrivateFieldGet(this, _EmulatorBindings_instances, "f").get(key);
        }
        // Create instance
        let emulator = this.invoke(module, '_create_emulator', [config.toBoc().toString('base64'), verbosity]);
        __classPrivateFieldGet(this, _EmulatorBindings_instances, "f").set(key, emulator);
        return emulator;
    }
}
exports.EmulatorBindings = EmulatorBindings;
_EmulatorBindings_lock = new WeakMap(), _EmulatorBindings_instances = new WeakMap(), _EmulatorBindings_module = new WeakMap(), _EmulatorBindings_errLogs = new WeakMap();
function prepareLogs(errors, stdout, vmLogs) {
    let logs = '';
    let debug = errors.filter((v) => v.startsWith('#DEBUG#'));
    let nonDebug = errors.filter((v) => !v.startsWith('#DEBUG#'));
    // Debug Logs
    if (debug.length > 0) {
        logs += '=== DEBUG LOGS ===\n';
        logs += debug.map((v) => v.slice('#DEBUG#: '.length)).join('\n');
        logs += '\n';
        logs += '\n';
    }
    // VM log
    if (vmLogs.length > 0) {
        logs += '=== VM LOGS ===\n';
        logs += vmLogs;
        logs += '\n';
        logs += '\n';
    }
    // Stdout
    if (stdout.length > 0) {
        logs += '=== STDOUT ===\n';
        logs += stdout;
        logs += '\n';
        logs += '\n';
    }
    // Stderr
    if (nonDebug.length > 0) {
        logs += '=== STDERR ===\n';
        logs += nonDebug.join('\n');
        logs += '\n';
        logs += '\n';
    }
    return logs;
}

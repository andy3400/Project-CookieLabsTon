import { Account, Address, Cell, ContractState, Message, TupleItem, TupleReader } from "ton-core";
import { ContractSystem } from "./ContractSystem";
export type GetMethodResult = {
    success: true;
    gasUsed: bigint;
    stack: TupleReader;
    exitCode: number;
    logs: string;
} | {
    success: false;
    error: string;
};
export declare class ContractExecutor {
    #private;
    static createEmpty(address: Address, system: ContractSystem): ContractExecutor;
    static create(args: {
        code: Cell;
        data: Cell;
        address?: Address;
        balance?: bigint;
    }, system: ContractSystem): Promise<ContractExecutor>;
    readonly system: ContractSystem;
    readonly address: Address;
    constructor(state: Account, system: ContractSystem);
    get state(): ContractState;
    get balance(): bigint;
    set balance(v: bigint);
    override: (code: Cell, data: Cell, balance: bigint) => void;
    get: (method: string | number, stack?: TupleItem[]) => Promise<GetMethodResult>;
    receive(msg: Message): Promise<{
        seq: number;
        tx: {
            address: bigint;
            lt: bigint;
            prevTransactionHash: bigint;
            prevTransactionLt: bigint;
            now: number;
            outMessagesCount: number;
            oldStatus: import("ton-core").AccountStatus;
            endStatus: import("ton-core").AccountStatus;
            inMessage: Message | undefined;
            outMessages: import("ton-core").Dictionary<number, Message>;
            totalFees: import("ton-core").CurrencyCollection;
            stateUpdate: import("ton-core").HashUpdate;
            description: import("ton-core").TransactionDescription;
        };
        logs: string;
    }>;
}

"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ContractSystem_instances, _ContractSystem_config, _ContractSystem_now, _ContractSystem_lt, _ContractSystem_bindings, _ContractSystem_contracts, _ContractSystem_abis, _ContractSystem_pending, _ContractSystem_trackers, _ContractSystem_loggers, _ContractSystem_verbosity, _ContractSystem_send, _ContractSystem_provider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractSystem = void 0;
const ton_core_1 = require("ton-core");
const EmulatorBindings_1 = require("../bindings/EmulatorBindings");
const tracker_1 = require("../events/tracker");
const logger_1 = require("../logger/logger");
const Treasure_1 = require("../treasure/Treasure");
const addressSource_1 = require("../utils/addressSource");
const defaultConfig_1 = require("../utils/defaultConfig");
const testKey_1 = require("../utils/testKey");
const ContractExecutor_1 = require("./ContractExecutor");
/**
 * Contract system is a container for contracts that interact with each other
 */
class ContractSystem {
    static async create(args) {
        return new ContractSystem(args);
    }
    /**
     * Get current network config
     */
    get config() {
        return __classPrivateFieldGet(this, _ContractSystem_config, "f");
    }
    /**
     * Current contract system time
     */
    get now() {
        return __classPrivateFieldGet(this, _ContractSystem_now, "f");
    }
    /**
     * VM bindings for contract system
     */
    get bindings() {
        return __classPrivateFieldGet(this, _ContractSystem_bindings, "f");
    }
    /**
     * LT of a contract system
     */
    get lt() {
        return __classPrivateFieldGet(this, _ContractSystem_lt, "f");
    }
    /**
     * Returns current verbosity level
     */
    get globalVerbosity() {
        return __classPrivateFieldGet(this, _ContractSystem_verbosity, "f");
    }
    constructor(args) {
        _ContractSystem_instances.add(this);
        _ContractSystem_config.set(this, void 0);
        _ContractSystem_now.set(this, void 0);
        _ContractSystem_lt.set(this, void 0);
        _ContractSystem_bindings.set(this, void 0);
        _ContractSystem_contracts.set(this, void 0);
        _ContractSystem_abis.set(this, void 0);
        _ContractSystem_pending.set(this, []);
        _ContractSystem_trackers.set(this, new Map());
        _ContractSystem_loggers.set(this, new Map());
        _ContractSystem_verbosity.set(this, 1 /* Verbosity.ERROR */);
        _ContractSystem_send.set(this, (src) => {
            if (src.info.type !== 'external-out') {
                __classPrivateFieldGet(this, _ContractSystem_pending, "f").push(src);
            }
        });
        if (args && args.config) {
            __classPrivateFieldSet(this, _ContractSystem_config, args.config, "f");
        }
        else {
            __classPrivateFieldSet(this, _ContractSystem_config, defaultConfig_1.defaultConfig, "f");
        }
        if (args && args.now) {
            __classPrivateFieldSet(this, _ContractSystem_now, args.now, "f");
        }
        else {
            __classPrivateFieldSet(this, _ContractSystem_now, Math.floor(Date.now() / 1000), "f");
        }
        if (args && args.lt) {
            __classPrivateFieldSet(this, _ContractSystem_lt, args.lt, "f");
        }
        else {
            __classPrivateFieldSet(this, _ContractSystem_lt, 0n, "f");
        }
        __classPrivateFieldSet(this, _ContractSystem_bindings, new EmulatorBindings_1.EmulatorBindings(), "f");
        __classPrivateFieldSet(this, _ContractSystem_contracts, new Map(), "f");
        __classPrivateFieldSet(this, _ContractSystem_abis, new Map(), "f");
    }
    /**
     * Open a treasure with a 1bn of TONs
     * @param seed random string that identifies a treasure
     * @param workchain optional workchain id
     * @returns treasure wallet
     */
    treasure(seed, workchain = 0) {
        // Create a treasure wallet
        let key = (0, testKey_1.testKey)(seed);
        let treasure = Treasure_1.TreasureContract.create(workchain, key);
        let wallet = this.open(treasure);
        // Update wallet balance and name
        let executor = this.contract(treasure.address);
        executor.balance = (0, ton_core_1.toNano)(1000000);
        executor.name = `treasure(${seed})`;
        // Return sender
        return wallet.sender(treasure.address);
    }
    /**
     * Override contract state
     * @param address
     * @param code
     * @param data
     * @param balance
     */
    override(address, code, data, balance) {
        this.contract(address).override(code, data, balance);
    }
    /**
     * Update system state
     */
    update(updates) {
        if (updates.now !== null && updates.now !== undefined) {
            __classPrivateFieldSet(this, _ContractSystem_now, updates.now, "f");
        }
        if (updates.config !== null && updates.config !== undefined) {
            __classPrivateFieldSet(this, _ContractSystem_config, updates.config, "f");
        }
        if (updates.lt !== null && updates.lt !== undefined) {
            __classPrivateFieldSet(this, _ContractSystem_lt, updates.lt, "f");
        }
    }
    /**
     * Get empty Contract Executor for a contract
     * @param contract contract address or contract instance
     * @returns contract executor
     */
    contract(contract) {
        let address = (0, addressSource_1.resolveAddress)(contract);
        let key = address.toString({ testOnly: true });
        let executor = __classPrivateFieldGet(this, _ContractSystem_contracts, "f").get(key);
        if (!executor) {
            executor = ContractExecutor_1.ContractExecutor.createEmpty(address, this);
            __classPrivateFieldGet(this, _ContractSystem_contracts, "f").set(key, executor);
        }
        return executor;
    }
    /**
     * Creates a provider for contract
     * @param contract contract address
     * @returns contract provider
     */
    provider(contract) {
        return __classPrivateFieldGet(this, _ContractSystem_instances, "m", _ContractSystem_provider).call(this, contract.address, contract.init && contract.init.code && contract.init.data ? contract.init : null);
    }
    /**
     * Open a contract
     * @param src contract
     * @returns opened contract
     */
    open(src) {
        // Register ABI
        if (src.abi) {
            __classPrivateFieldGet(this, _ContractSystem_abis, "f").set(src.address.toString({ testOnly: true }), src.abi);
        }
        // Open contract
        return (0, ton_core_1.openContract)(src, (params) => __classPrivateFieldGet(this, _ContractSystem_instances, "m", _ContractSystem_provider).call(this, params.address, params.init));
    }
    /**
     * Run until stop
     */
    async run() {
        let result = [];
        while (__classPrivateFieldGet(this, _ContractSystem_pending, "f").length > 0) {
            let p = __classPrivateFieldGet(this, _ContractSystem_pending, "f").shift(); // TODO: Better (random?) way to select pending message
            if (p.info.type === 'internal' || p.info.type === 'external-in') {
                // Execute
                let tx = await this.contract(p.info.dest).receive(p);
                let key = p.info.dest.toString({ testOnly: true });
                // Track
                let t = __classPrivateFieldGet(this, _ContractSystem_trackers, "f").get(key);
                if (t) {
                    for (let tr of t) {
                        tr.track(tx.seq, tx.tx, this);
                    }
                }
                // Logs
                let l = __classPrivateFieldGet(this, _ContractSystem_loggers, "f").get(key);
                if (l) {
                    for (let tr of l) {
                        tr.track(tx.seq, tx.logs, this);
                    }
                }
                // Add to result
                result.push(tx.tx);
                // Add to pending
                for (let m of tx.tx.outMessages.values()) {
                    __classPrivateFieldGet(this, _ContractSystem_send, "f").call(this, m);
                }
            }
        }
        return result;
    }
    /**
     * Create a tracker for a contract
     * @param address contract or it's address
     */
    track(contract) {
        let address = (0, addressSource_1.resolveAddress)(contract);
        let tracker = new tracker_1.Tracker(address);
        let key = address.toString({ testOnly: true });
        let trackers = __classPrivateFieldGet(this, _ContractSystem_trackers, "f").get(key);
        if (!trackers) {
            trackers = [];
            __classPrivateFieldGet(this, _ContractSystem_trackers, "f").set(key, trackers);
        }
        trackers.push(tracker);
        return tracker;
    }
    /**
     * Create a logger for a contract
     * @param address contract or it's address
     */
    log(contract) {
        let address = (0, addressSource_1.resolveAddress)(contract);
        let logger = new logger_1.Logger(address);
        let key = address.toString({ testOnly: true });
        let loggers = __classPrivateFieldGet(this, _ContractSystem_loggers, "f").get(key);
        if (!loggers) {
            loggers = [];
            __classPrivateFieldGet(this, _ContractSystem_loggers, "f").set(key, loggers);
        }
        loggers.push(logger);
        return logger;
    }
    /**
     * Sets contract name
     * @param contract contract or it's address
     * @param name optional name
     */
    name(contract, name) {
        this.contract(contract).name = name;
    }
    /**
     * Verbose level for a contract
     * @param contract contract or it's address
     * @param level verbosity level
     */
    verbosity(contract, level) {
        this.contract(contract).verbosity = level;
    }
    /**
     * Send external message
     * @param message
     */
    send(message) {
        if (message.info.type !== 'external-in') {
            throw Error('Message is not external-in');
        }
        __classPrivateFieldGet(this, _ContractSystem_send, "f").call(this, message);
    }
    //
    // Utility
    //
    getContractError(address, code) {
        let b = __classPrivateFieldGet(this, _ContractSystem_abis, "f").get(address.toString({ testOnly: true }));
        if (!b) {
            return null;
        }
        if (b.errors && b.errors[code]) {
            return b.errors[code].message;
        }
        else {
            return null;
        }
    }
    getContractName(address) {
        let ex = __classPrivateFieldGet(this, _ContractSystem_contracts, "f").get(address.toString({ testOnly: true }));
        if (!ex) {
            return null;
        }
        return ex.name;
    }
}
exports.ContractSystem = ContractSystem;
_ContractSystem_config = new WeakMap(), _ContractSystem_now = new WeakMap(), _ContractSystem_lt = new WeakMap(), _ContractSystem_bindings = new WeakMap(), _ContractSystem_contracts = new WeakMap(), _ContractSystem_abis = new WeakMap(), _ContractSystem_pending = new WeakMap(), _ContractSystem_trackers = new WeakMap(), _ContractSystem_loggers = new WeakMap(), _ContractSystem_verbosity = new WeakMap(), _ContractSystem_send = new WeakMap(), _ContractSystem_instances = new WeakSet(), _ContractSystem_provider = function _ContractSystem_provider(address, init) {
    let executor = this.contract(address);
    return {
        getState: async () => {
            return executor.state;
        },
        get: async (name, args) => {
            let res = await executor.get(name, args);
            if (!res.success) {
                throw Error(res.error);
            }
            if (res.exitCode !== 0 && res.exitCode !== 1) {
                let abi = __classPrivateFieldGet(this, _ContractSystem_abis, "f").get(address.toString({ testOnly: true }));
                if (abi && abi.errors && abi.errors[res.exitCode]) {
                    throw new ton_core_1.ComputeError(abi.errors[res.exitCode].message, res.exitCode, { logs: res.logs });
                }
                else {
                    throw new ton_core_1.ComputeError('Exit code: ' + res.exitCode, res.exitCode, { logs: res.logs });
                }
            }
            return { stack: res.stack, gasUsed: res.gasUsed, logs: res.logs };
        },
        internal: async (via, message) => {
            // Resolve if init needed
            let state = executor.state;
            let neededInit = undefined;
            if (state.state.type !== 'active' && init) {
                neededInit = init;
            }
            // Resolve bounce
            let bounce = true;
            if (message.bounce !== null && message.bounce !== undefined) {
                bounce = message.bounce;
            }
            // Resolve value
            let value;
            if (typeof message.value === 'string') {
                value = (0, ton_core_1.toNano)(message.value);
            }
            else {
                value = message.value;
            }
            // Resolve body
            let body = null;
            if (typeof message.body === 'string') {
                body = (0, ton_core_1.comment)(message.body);
            }
            else if (message.body) {
                body = message.body;
            }
            // Send internal message
            await via.send({
                to: address,
                value,
                bounce,
                sendMode: message.sendMode,
                init: neededInit,
                body
            });
        },
        external: async (msg) => {
            // Resolve if init needed
            let state = executor.state;
            let neededInit = undefined;
            if (state.state.type !== 'active' && init) {
                neededInit = init;
            }
            // Send message
            __classPrivateFieldGet(this, _ContractSystem_send, "f").call(this, (0, ton_core_1.external)({
                to: address,
                init: neededInit,
                body: msg
            }));
        }
    };
};
